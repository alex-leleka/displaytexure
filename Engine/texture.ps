////////////////////////////////////////////////////////////////////////////////
// Filename: texture.ps
////////////////////////////////////////////////////////////////////////////////
cbuffer PerFrameBufferPs : register(b1)
{
	float4 dir;
};

/////////////
// GLOBALS //
/////////////
Texture2D shaderTexture;
SamplerState SampleType;

//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
};

static const float offset[] = {0.0, 1.0, 2.0, 3.0, 4.0};
static const float weight[] = {
  0.2270270270, 0.1945945946, 0.1216216216,
  0.0540540541, 0.0162162162
};

float pattern(float2 pos)
{
	float xbound = 0.5;
	if (pos.x < xbound)
		return 0.0;
	return 1.0;
}
////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 TexturePixelShader(PixelInputType input) : SV_TARGET
{
	if (pattern(input.tex) == 0.0)
		return shaderTexture.Sample(SampleType, input.tex);
	float4 ppColour = shaderTexture.Sample(SampleType, input.tex) * weight[0];
	float3 FragmentColor = float3(0.0f, 0.0f, 0.0f);

	//(1.0, 0.0) -> horizontal blur
	//(0.0, 1.0) -> vertical blur


	float2 scr_size = float2(800, 600);

	float hstep = dir.x / scr_size.x;
	float vstep = dir.y / scr_size.y;

	for (int i = 1; i < 5; i++) {
	FragmentColor = FragmentColor +
		shaderTexture.Sample(SampleType, input.tex + float2(hstep*offset[i], vstep*offset[i]))*weight[i] +
		shaderTexture.Sample(SampleType, input.tex - float2(hstep*offset[i], vstep*offset[i]))*weight[i];      
	}
	ppColour = ppColour + float4(FragmentColor,0.0f);
	float4 color = ppColour;
	return color;

}
